// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: merchants.sql

package db

import (
	"context"
)

const createMerchant = `-- name: CreateMerchant :one
INSERT INTO merchants ("merchant_name", "commission") 
VALUES ($1, $2) RETURNING merchant_id, merchant_name, commission, created_at, updated_at
`

type CreateMerchantParams struct {
	MerchantName string  `json:"merchant_name"`
	Commission   float64 `json:"commission"`
}

func (q *Queries) CreateMerchant(ctx context.Context, arg CreateMerchantParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, createMerchant, arg.MerchantName, arg.Commission)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantName,
		&i.Commission,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const paginateAscMerchants = `-- name: PaginateAscMerchants :many
SELECT merchant_id, merchant_name, commission, created_at, updated_at FROM merchants WHERE "merchant_name" LIKE $1 ORDER BY $2 ASC LIMIT $3 OFFSET $4
`

type PaginateAscMerchantsParams struct {
	MerchantName string      `json:"merchant_name"`
	Column2      interface{} `json:"column_2"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

func (q *Queries) PaginateAscMerchants(ctx context.Context, arg PaginateAscMerchantsParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, paginateAscMerchants,
		arg.MerchantName,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.MerchantID,
			&i.MerchantName,
			&i.Commission,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateCountMerchants = `-- name: PaginateCountMerchants :one
SELECT count(*) FROM merchants WHERE "merchant_name" LIKE $1
`

// Paginate - Control
func (q *Queries) PaginateCountMerchants(ctx context.Context, merchantName string) (int64, error) {
	row := q.db.QueryRow(ctx, paginateCountMerchants, merchantName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const paginateDescMerchants = `-- name: PaginateDescMerchants :many
SELECT merchant_id, merchant_name, commission, created_at, updated_at FROM merchants WHERE "merchant_name" LIKE $1 ORDER BY $2 DESC LIMIT $3 OFFSET $4
`

type PaginateDescMerchantsParams struct {
	MerchantName string      `json:"merchant_name"`
	Column2      interface{} `json:"column_2"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

func (q *Queries) PaginateDescMerchants(ctx context.Context, arg PaginateDescMerchantsParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, paginateDescMerchants,
		arg.MerchantName,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.MerchantID,
			&i.MerchantName,
			&i.Commission,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readMerchant = `-- name: ReadMerchant :one
SELECT merchant_id, merchant_name, commission, created_at, updated_at FROM merchants WHERE "merchant_id" = $1 LIMIT 1
`

func (q *Queries) ReadMerchant(ctx context.Context, merchantID int32) (Merchant, error) {
	row := q.db.QueryRow(ctx, readMerchant, merchantID)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantName,
		&i.Commission,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMerchant = `-- name: UpdateMerchant :one
UPDATE merchants SET "merchant_name" = $1, "commission" = $2, "updated_at" = CURRENT_TIMESTAMP 
WHERE "merchant_id" = $3 RETURNING merchant_id, merchant_name, commission, created_at, updated_at
`

type UpdateMerchantParams struct {
	MerchantName string  `json:"merchant_name"`
	Commission   float64 `json:"commission"`
	MerchantID   int32   `json:"merchant_id"`
}

func (q *Queries) UpdateMerchant(ctx context.Context, arg UpdateMerchantParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, updateMerchant, arg.MerchantName, arg.Commission, arg.MerchantID)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantName,
		&i.Commission,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
